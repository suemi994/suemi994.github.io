---
layout: post
title: 设计模式之职责链模式
category: 编程技巧
tags: 设计模式
date: 2015-02-24
---
{% include JB/setup %}

* 目录
{:toc}

### 前言

这是本人的设计模式学习笔记，把自己学习过程中的一些总结和认识记录下来，与诸君共勉。本日为大家带来职责链模式。

### 基本概念

职责链属于行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。

在这里客户端和处理者都没有对方明确的信息，同时处理者也不知道职责链中的结构。所以职责链可以简化对象的相互连接，他们只需要保存一个指向其后续者的引用，而不需要保存所有候选者的引用。

在职责链模式中我们可以随时随地的增加或者更改一个处理者，甚至可以更改处理者的顺序，增加了系统的灵活性。处理灵活性是增加了，但是有时候可能会导致一个请求无论如何也得不到处理，它会被放置在链末端，这个既是职责链的优点也是缺点。


- Handler：抽象处理者。定义了一个处理请求的方法。所有的处理者都必须实现该抽象类。 
- ConcreteHandler: 具体处理者。处理它所负责的请求，同时也可以访问它的后继者。如果它能够处理该请求则处理，否则将请求传递到它的后继者。 
- Client: 客户类。

![职责链模式结构示意图](/assets/img/2015-02-24-0.png)


### 特点

优点：

- 降低耦合度。它将请求的发送者和接受者解耦。
- 简化了对象。使得对象不需要知道链的结构。
- 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。
- 增加新的请求处理类很方便。

缺点：

- 不能保证请求一定被接收。
- 系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。
- 可能不容易观察运行时的特征，有碍于除错。

### 适用场景

1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。
2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
3. 可动态指定一组对象处理请求。

#### 组合+职责链
组合模式和职责链模式的结合十分常见，为了说明这一点，我们先考察HTML的DOM树的事件系统，就是一个典型的组合+职责链模式，不过事件是向上传播的是冒泡的，而在许多情况中，请求是向下传播的。

一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一个是承担责任，二是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况。

在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。纯的责任链模式的例子是不容易找到的，一般看到的例子均是不纯的责任链模式的实现。

